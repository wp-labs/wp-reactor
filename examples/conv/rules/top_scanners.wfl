use "network.wfs"

# Top-N port scanners per fixed window.
#
# Uses a fixed 1-hour window to group SYN events by source IP.
# The on_event step is trivially satisfied (count >= 1) so event_ok
# is set; the real threshold is in on_close (distinct ports >= 3).
# When the window expires, conv sorts IPs by scan count (descending)
# and keeps only the top 2 — filtering out low-activity scanners.

rule top_port_scanners {
    events { c : conn_events && action == "syn" }

    match<sip:1h:fixed> {
        on event {
            c | count >= 1;
        }
        on close {
            scan: c.dport | distinct | count >= 3;
        }
    } -> score(80.0)

    entity(ip, c.sip)

    yield network_alerts (
        sip = c.sip,
        alert_type = "port_scan",
        detail = "top scanner by distinct ports"
    )

    conv {
        sort(-scan) | top(2) ;
    }
}

# -----------------------------------------------------------------------
# Test: 3 IPs scanning different numbers of ports in the same window.
# Conv keeps only the top 2 scanners (sorted by distinct port count).
# -----------------------------------------------------------------------

test top2_scanners for top_port_scanners {
    input {
        # IP-A: scans 5 distinct ports → scan=5
        row(c, sip = "10.0.0.1", dip = "192.168.1.1", dport = "80",    action = "syn", event_time = "2026-01-01T00:00:01Z");
        row(c, sip = "10.0.0.1", dip = "192.168.1.1", dport = "443",   action = "syn", event_time = "2026-01-01T00:00:02Z");
        row(c, sip = "10.0.0.1", dip = "192.168.1.1", dport = "8080",  action = "syn", event_time = "2026-01-01T00:00:03Z");
        row(c, sip = "10.0.0.1", dip = "192.168.1.1", dport = "22",    action = "syn", event_time = "2026-01-01T00:00:04Z");
        row(c, sip = "10.0.0.1", dip = "192.168.1.1", dport = "3306",  action = "syn", event_time = "2026-01-01T00:00:05Z");

        # IP-B: scans 3 distinct ports → scan=3
        row(c, sip = "10.0.0.2", dip = "192.168.1.1", dport = "80",    action = "syn", event_time = "2026-01-01T00:00:06Z");
        row(c, sip = "10.0.0.2", dip = "192.168.1.1", dport = "443",   action = "syn", event_time = "2026-01-01T00:00:07Z");
        row(c, sip = "10.0.0.2", dip = "192.168.1.1", dport = "8080",  action = "syn", event_time = "2026-01-01T00:00:08Z");

        # IP-C: scans 4 distinct ports → scan=4
        row(c, sip = "10.0.0.3", dip = "192.168.1.1", dport = "22",    action = "syn", event_time = "2026-01-01T00:00:09Z");
        row(c, sip = "10.0.0.3", dip = "192.168.1.1", dport = "3306",  action = "syn", event_time = "2026-01-01T00:00:10Z");
        row(c, sip = "10.0.0.3", dip = "192.168.1.1", dport = "5432",  action = "syn", event_time = "2026-01-01T00:00:11Z");
        row(c, sip = "10.0.0.3", dip = "192.168.1.1", dport = "6379",  action = "syn", event_time = "2026-01-01T00:00:12Z");

        # Advance clock past the 1h window to expire all buckets
        tick(2h);
    }
    expect {
        # 3 IPs all satisfy scan >= 3, but conv keeps only top 2
        hits == 2;
        hit[0].entity_id == "10.0.0.1";
        hit[1].entity_id == "10.0.0.3";
    }
    options {
        close_trigger = timeout;
    }
}

# -----------------------------------------------------------------------
# Test: without enough distinct ports → no alerts
# -----------------------------------------------------------------------

test below_threshold for top_port_scanners {
    input {
        row(c, sip = "10.0.0.1", dip = "192.168.1.1", dport = "80",  action = "syn", event_time = "2026-01-01T00:00:01Z");
        row(c, sip = "10.0.0.1", dip = "192.168.1.1", dport = "443", action = "syn", event_time = "2026-01-01T00:00:02Z");
        tick(2h);
    }
    expect {
        hits == 0;
    }
    options {
        close_trigger = timeout;
    }
}
