use super::*;
use crate::oracle::run_oracle;

#[test]
fn test_inject_hit_cluster_correctness() {
    let input = r#"
#[duration=10s]
scenario inject_hit<seed=42> {
    traffic {
        stream LoginWindow gen 100/s
    }
    injection {
        hit<50%> LoginWindow {
            src_ip seq {
                use(action="failed") with(5,2m)
            }
        }
    }
    expect {
        hit(brute_force) >= 0%
    }
}
"#;
    let wfg = parse_wfg(input).unwrap();
    let schemas = vec![make_login_schema()];
    let plans = vec![make_brute_force_plan()];

    let result = generate(&wfg, &schemas, &plans).unwrap();
    assert_eq!(result.events.len(), 1000);

    // Hit clusters: 1000 * 50% = 500 events / 5 per cluster = 100 clusters
    // Count events that are inject hit events by checking src_ip pattern
    let hit_events: Vec<_> = result
        .events
        .iter()
        .filter(|e| {
            e.fields
                .get("src_ip")
                .and_then(|v| v.as_str())
                .map(|s| s.starts_with("10."))
                .unwrap_or(false)
                && e.fields
                    .get("src_ip")
                    .and_then(|v| v.as_str())
                    .unwrap_or("")
                    .len()
                    <= 15 // typical inject IP pattern
        })
        .collect();

    // At minimum we should have some hit events
    assert!(
        hit_events.len() >= 100,
        "expected at least 100 hit events, got {}",
        hit_events.len()
    );

    // All events should be sorted by timestamp
    for w in result.events.windows(2) {
        assert!(w[0].timestamp <= w[1].timestamp);
    }
}

#[test]
fn test_inject_filter_constraint_applied() {
    // Rule has filter: success == false
    // Generated inject events must have success = false
    let input = r#"
#[duration=5s]
scenario inject_filter<seed=42> {
    traffic {
        stream LoginWindow gen 100/s
    }
    injection {
        hit<30%> LoginWindow {
            src_ip seq {
                use(success=false) with(5,2m)
            }
        }
    }
    expect {
        hit(auth_fail_rule) >= 0%
    }
}
"#;
    let wfg = parse_wfg(input).unwrap();
    let schemas = vec![make_login_schema()];
    let plans = vec![make_auth_fail_plan()];

    let result = generate(&wfg, &schemas, &plans).unwrap();
    assert_eq!(result.events.len(), 500);

    // Inject events are identified by src_ip pattern "10.x.x.x" (generated by generate_key_values)
    // Background events have different IPs from the ipv4() generator
    // Count inject events (those with src_ip starting with "10." and having typical inject pattern)
    let inject_events: Vec<_> = result
        .events
        .iter()
        .filter(|e| {
            e.fields
                .get("src_ip")
                .and_then(|v| v.as_str())
                .map(|s| s.starts_with("10.") && s.len() <= 15)
                .unwrap_or(false)
        })
        .collect();

    // Debug: print first 10 inject events
    for (i, event) in inject_events.iter().take(10).enumerate() {
        eprintln!(
            "Inject event {}: src_ip={:?}, success={:?}",
            i,
            event.fields.get("src_ip"),
            event.fields.get("success")
        );
    }

    // All inject events should have success = false due to filter
    for (i, event) in inject_events.iter().enumerate() {
        let success = event.fields.get("success").and_then(|v| v.as_bool());
        assert_eq!(
            success,
            Some(false),
            "inject event {} should have success=false due to filter, got {:?}",
            i,
            success
        );
    }

    // Run oracle — should produce alerts because inject events match filter and threshold
    let start = "2024-01-01T00:00:00Z".parse().unwrap();
    let duration = Duration::from_secs(3600);
    let oracle = run_oracle(&result.events, &plans, &start, &duration, None).unwrap();

    // We expect alerts since hit events have the correct filter value
    assert!(
        !oracle.alerts.is_empty(),
        "expected alerts from hit events with filter, got {}",
        oracle.alerts.len()
    );
}

#[test]
fn test_inject_near_miss_no_trigger() {
    // near-miss events should produce N-1 events per cluster (not enough to trigger)
    let input = r#"
#[duration=10s]
scenario inject_nm<seed=42> {
    traffic {
        stream LoginWindow gen 100/s
    }
    injection {
        near_miss<40%> LoginWindow {
            src_ip seq {
                use(action="failed") with(5,2m)
            }
        }
    }
    expect {
        hit(brute_force) >= 0%
    }
}
"#;
    let wfg = parse_wfg(input).unwrap();
    let schemas = vec![make_login_schema()];
    let plans = vec![make_brute_force_plan()];

    let result = generate(&wfg, &schemas, &plans).unwrap();
    assert_eq!(result.events.len(), 1000);

    // Run oracle — near-miss clusters should NOT produce alerts
    let start = "2024-01-01T00:00:00Z".parse().unwrap();
    let duration = Duration::from_secs(3600);
    let oracle = run_oracle(&result.events, &plans, &start, &duration, None).unwrap();
    assert_eq!(
        oracle.alerts.len(),
        0,
        "near-miss clusters should not trigger any alerts"
    );
}

#[test]
fn test_inject_hit_triggers_oracle() {
    let input = r#"
#[duration=10s]
scenario inject_oracle<seed=42> {
    traffic {
        stream LoginWindow gen 100/s
    }
    injection {
        hit<50%> LoginWindow {
            src_ip seq {
                use(action="failed") with(5,2m)
            }
        }
    }
    expect {
        hit(brute_force) >= 0%
    }
}
"#;
    let wfg = parse_wfg(input).unwrap();
    let schemas = vec![make_login_schema()];
    let plans = vec![make_brute_force_plan()];

    let result = generate(&wfg, &schemas, &plans).unwrap();

    // Run oracle — hit clusters should produce alerts
    let start = "2024-01-01T00:00:00Z".parse().unwrap();
    let duration = Duration::from_secs(3600);
    let oracle = run_oracle(&result.events, &plans, &start, &duration, None).unwrap();

    // 1000 events * 50% = 500 hit events / 5 per cluster = 100 clusters → 100 alerts
    assert_eq!(
        oracle.alerts.len(),
        100,
        "expected 100 alerts from 100 hit clusters, got {}",
        oracle.alerts.len()
    );

    // All alerts should have correct rule name and score
    for alert in &oracle.alerts {
        assert_eq!(alert.rule_name, "brute_force");
        assert!((alert.score - 85.0).abs() < f64::EPSILON);
        assert_eq!(alert.entity_type, "ip");
    }
}

#[test]
fn test_inject_budget_allocation() {
    // hit% + near_miss% + non_hit% should be accounted for; rest is background
    let input = r#"
#[duration=10s]
scenario inject_budget<seed=42> {
    traffic {
        stream LoginWindow gen 100/s
    }
    injection {
        hit<30%> LoginWindow {
            src_ip seq {
                use(action="failed") with(5,2m)
            }
        }
        near_miss<10%> LoginWindow {
            src_ip seq {
                use(action="failed") with(5,2m)
            }
        }
        miss<20%> LoginWindow {
            src_ip seq {
                use(action="success") with(1,30s)
            }
        }
    }
    expect {
        hit(brute_force) >= 0%
    }
}
"#;
    let wfg = parse_wfg(input).unwrap();
    let schemas = vec![make_login_schema()];
    let plans = vec![make_brute_force_plan()];

    let result = generate(&wfg, &schemas, &plans).unwrap();
    // Total should still be 1000
    assert_eq!(result.events.len(), 1000);
}

#[test]
fn test_inject_deterministic() {
    let input = r#"
#[duration=5s]
scenario inject_det<seed=42> {
    traffic {
        stream LoginWindow gen 100/s
    }
    injection {
        hit<30%> LoginWindow {
            src_ip seq {
                use(action="failed") with(5,2m)
            }
        }
    }
    expect {
        hit(brute_force) >= 0%
    }
}
"#;
    let wfg = parse_wfg(input).unwrap();
    let schemas = vec![make_login_schema()];
    let plans = vec![make_brute_force_plan()];

    let result1 = generate(&wfg, &schemas, &plans).unwrap();
    let result2 = generate(&wfg, &schemas, &plans).unwrap();

    assert_eq!(result1.events.len(), result2.events.len());
    for (e1, e2) in result1.events.iter().zip(result2.events.iter()) {
        assert_eq!(e1.timestamp, e2.timestamp);
        assert_eq!(e1.fields, e2.fields);
    }
}
